from pathlib import Path
from typing import Any, Callable, Literal, Protocol, Self, overload
from abc import ABCMeta, abstractmethod

from iminuit import Minuit
from numpy.typing import ArrayLike
from scipy.optimize import OptimizeResult

__version__: str

class Parameter:
    amplitude: str
    name: str
    index: int | None
    fixed_index: int | None
    free: bool
    fixed: bool
    initial: float
    bounds: tuple[float, float]

    def __init__(self, amplitude: str, name: str, index: int) -> None: ...

class Parameter64:
    amplitude: str
    name: str
    index: int | None
    fixed_index: int | None
    free: bool
    fixed: bool
    initial: float
    bounds: tuple[float, float]

    def __init__(self, amplitude: str, name: str, index: int) -> None: ...

class Parameter32:
    amplitude: str
    name: str
    index: int | None
    fixed_index: int | None
    free: bool
    fixed: bool
    initial: float
    bounds: tuple[float, float]

    def __init__(self, amplitude: str, name: str, index: int) -> None: ...

class PyNode(metaclass=ABCMeta):
    @abstractmethod
    def precalculate(self, dataset: Dataset) -> None: ...
    @abstractmethod
    def calculate(self, parameters: list[float], event: Event) -> complex: ...
    @abstractmethod
    def parameters(self) -> list[str]: ...

class PyNode64(metaclass=ABCMeta):
    @abstractmethod
    def precalculate(self, dataset: Dataset64) -> None: ...
    @abstractmethod
    def calculate(self, parameters: list[float], event: Event) -> complex: ...
    @abstractmethod
    def parameters(self) -> list[str]: ...

class PyNode32(metaclass=ABCMeta):
    @abstractmethod
    def precalculate(self, dataset: Dataset32) -> None: ...
    @abstractmethod
    def calculate(self, parameters: list[float], event: Event) -> complex: ...
    @abstractmethod
    def parameters(self) -> list[str]: ...

class Node:
    def __init__(self, pynode: PyNode) -> None: ...
    def precalculate(self, dataset: Dataset) -> None: ...
    def calculate(self, parameters: list[float], event: Event) -> complex: ...
    def parameters(self) -> list[str]: ...
    def into_amplitude(self, name: str) -> Amplitude: ...

class Node64:
    def __init__(self, pynode: PyNode64) -> None: ...
    def precalculate(self, dataset: Dataset64) -> None: ...
    def calculate(self, parameters: list[float], event: Event) -> complex: ...
    def parameters(self) -> list[str]: ...
    def into_amplitude(self, name: str) -> Amplitude64: ...

class Node32:
    def __init__(self, pynode: PyNode32) -> None: ...
    def precalculate(self, dataset: Dataset32) -> None: ...
    def calculate(self, parameters: list[float], event: Event) -> complex: ...
    def parameters(self) -> list[str]: ...
    def into_amplitude(self, name: str) -> Amplitude32: ...

class Amplitude:
    name: str
    active: bool
    cache_position: int
    parameter_index_start: int

    def __init__(self, name: str, node: Node) -> None: ...
    def as_cohsum(self) -> CohSum: ...
    def real(self) -> Real: ...
    def imag(self) -> Imag: ...
    def __add__(self, other: Self | Real | Imag | Product | CohSum) -> CohSum: ...
    @overload
    def __mul__(self, other: Self | Real | Imag | Product) -> Product: ...
    @overload
    def __mul__(self, other: CohSum) -> CohSum: ...

class Amplitude64:
    name: str
    active: bool
    cache_position: int
    parameter_index_start: int

    def __init__(self, name: str, node: Node64) -> None: ...
    def as_cohsum(self) -> CohSum64: ...
    def real(self) -> Real64: ...
    def imag(self) -> Imag64: ...
    def __add__(self, other: Self | Real64 | Imag64 | Product64 | CohSum64) -> CohSum64: ...
    @overload
    def __mul__(self, other: Self | Real64 | Imag64 | Product64) -> Product64: ...
    @overload
    def __mul__(self, other: CohSum64) -> CohSum64: ...

class Amplitude32:
    name: str
    active: bool
    cache_position: int
    parameter_index_start: int

    def __init__(self, name: str, node: Node32) -> None: ...
    def as_cohsum(self) -> CohSum32: ...
    def real(self) -> Real32: ...
    def imag(self) -> Imag32: ...
    def __add__(self, other: Self | Real32 | Imag32 | Product32 | CohSum32) -> CohSum32: ...
    @overload
    def __mul__(self, other: Self | Real32 | Imag32 | Product32) -> Product32: ...
    @overload
    def __mul__(self, other: CohSum32) -> CohSum32: ...

class Real:
    def as_cohsum(self) -> CohSum: ...
    def real(self) -> Real: ...
    def imag(self) -> Imag: ...
    def __add__(self, other: Self | Real | Imag | Product | CohSum) -> CohSum: ...
    @overload
    def __mul__(self, other: Self | Real | Imag | Product) -> Product: ...
    @overload
    def __mul__(self, other: CohSum) -> CohSum: ...

class Real64:
    def as_cohsum(self) -> CohSum64: ...
    def real(self) -> Real64: ...
    def imag(self) -> Imag64: ...
    def __add__(self, other: Self | Real64 | Imag64 | Product64 | CohSum64) -> CohSum64: ...
    @overload
    def __mul__(self, other: Self | Real64 | Imag64 | Product64) -> Product64: ...
    @overload
    def __mul__(self, other: CohSum64) -> CohSum64: ...

class Real32:
    def as_cohsum(self) -> CohSum32: ...
    def real(self) -> Real32: ...
    def imag(self) -> Imag32: ...
    def __add__(self, other: Self | Real32 | Imag32 | Product32 | CohSum32) -> CohSum32: ...
    @overload
    def __mul__(self, other: Self | Real32 | Imag32 | Product32) -> Product32: ...
    @overload
    def __mul__(self, other: CohSum32) -> CohSum32: ...

class Imag:
    def as_cohsum(self) -> CohSum: ...
    def real(self) -> Real: ...
    def imag(self) -> Imag: ...
    def __add__(self, other: Self | Real | Imag | Product | CohSum) -> CohSum: ...
    @overload
    def __mul__(self, other: Self | Real | Imag | Product) -> Product: ...
    @overload
    def __mul__(self, other: CohSum) -> CohSum: ...

class Imag64:
    def as_cohsum(self) -> CohSum64: ...
    def real(self) -> Real64: ...
    def imag(self) -> Imag64: ...
    def __add__(self, other: Self | Real64 | Imag64 | Product64 | CohSum64) -> CohSum64: ...
    @overload
    def __mul__(self, other: Self | Real64 | Imag64 | Product64) -> Product64: ...
    @overload
    def __mul__(self, other: CohSum64) -> CohSum64: ...

class Imag32:
    def as_cohsum(self) -> CohSum32: ...
    def real(self) -> Real32: ...
    def imag(self) -> Imag32: ...
    def __add__(self, other: Self | Real32 | Imag32 | Product32 | CohSum32) -> CohSum32: ...
    @overload
    def __mul__(self, other: Self | Real32 | Imag32 | Product32) -> Product32: ...
    @overload
    def __mul__(self, other: CohSum32) -> CohSum32: ...

class Product:
    def as_cohsum(self) -> CohSum: ...
    def real(self) -> Real: ...
    def imag(self) -> Imag: ...
    def __add__(self, other: Self | Real | Imag | Product | CohSum) -> CohSum: ...
    @overload
    def __mul__(self, other: Self | Real | Imag | Product) -> Product: ...
    @overload
    def __mul__(self, other: CohSum) -> CohSum: ...

class Product64:
    def as_cohsum(self) -> CohSum64: ...
    def real(self) -> Real64: ...
    def imag(self) -> Imag64: ...
    def __add__(self, other: Self | Real64 | Imag64 | Product64 | CohSum64) -> CohSum64: ...
    @overload
    def __mul__(self, other: Self | Real64 | Imag64 | Product64) -> Product64: ...
    @overload
    def __mul__(self, other: CohSum64) -> CohSum64: ...

class Product32:
    def as_cohsum(self) -> CohSum32: ...
    def real(self) -> Real32: ...
    def imag(self) -> Imag32: ...
    def __add__(self, other: Self | Real32 | Imag32 | Product32 | CohSum32) -> CohSum32: ...
    @overload
    def __mul__(self, other: Self | Real32 | Imag32 | Product32) -> Product32: ...
    @overload
    def __mul__(self, other: CohSum32) -> CohSum32: ...

def Scalar(name: str) -> Amplitude: ...
def Scalar64(name: str) -> Amplitude64: ...
def Scalar32(name: str) -> Amplitude32: ...
def CScalar(name: str) -> Amplitude: ...
def CScalar64(name: str) -> Amplitude64: ...
def CScalar32(name: str) -> Amplitude32: ...
def PCScalar(name: str) -> Amplitude: ...
def PCScalar64(name: str) -> Amplitude64: ...
def PCScalar32(name: str) -> Amplitude32: ...
def PiecewiseM64(name: str, bins: int, range: tuple[float, float]) -> Amplitude64: ...
def PiecewiseM32(name: str, bins: int, range: tuple[float, float]) -> Amplitude32: ...

class CohSum:
    def __init__(self, terms: list[Amplitude | Real | Imag | Product | CohSum]) -> None: ...
    def __add__(self, other: Self | Amplitude | Real | Imag | Product) -> Self: ...
    def __mul__(self, other: Amplitude | Real | Imag | Product) -> CohSum: ...

class CohSum64:
    def __init__(
        self, terms: list[Amplitude64 | Real64 | Imag64 | Product64 | CohSum64]
    ) -> None: ...
    def __add__(self, other: Self | Amplitude64 | Real64 | Imag64 | Product64) -> Self: ...
    def __mul__(self, other: Amplitude64 | Real64 | Imag64 | Product64) -> CohSum64: ...

class CohSum32:
    def __init__(
        self, terms: list[Amplitude32 | Real32 | Imag32 | Product32 | CohSum32]
    ) -> None: ...
    def __add__(self, other: Self | Amplitude32 | Real32 | Imag32 | Product32) -> Self: ...
    def __mul__(self, other: Amplitude32 | Real32 | Imag32 | Product32) -> CohSum32: ...

class Model:
    cohsums: list[CohSum]
    amplitudes: list[Amplitude]
    parameters: list[Parameter]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, cohsums: list[CohSum]) -> None: ...
    def get_parameter(self, amplitude_name: str, parameter_name: str) -> Parameter | None: ...
    def print_parameters(self) -> None: ...
    def constrain(
        self, amplitude_1: str, parameter_1: str, amplitude_2: str, parameter_2: str
    ) -> None: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class Model64:
    cohsums: list[CohSum64]
    amplitudes: list[Amplitude64]
    parameters: list[Parameter64]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, cohsums: list[CohSum64]) -> None: ...
    def get_parameter(self, amplitude_name: str, parameter_name: str) -> Parameter64 | None: ...
    def print_parameters(self) -> None: ...
    def constrain(
        self, amplitude_1: str, parameter_1: str, amplitude_2: str, parameter_2: str
    ) -> None: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class Model32:
    cohsums: list[CohSum32]
    amplitudes: list[Amplitude32]
    parameters: list[Parameter32]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, cohsums: list[CohSum32]) -> None: ...
    def get_parameter(self, amplitude_name: str, parameter_name: str) -> Parameter32 | None: ...
    def print_parameters(self) -> None: ...
    def constrain(
        self, amplitude_1: str, parameter_1: str, amplitude_2: str, parameter_2: str
    ) -> None: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class FourMomentum:
    e: float
    px: float
    py: float
    pz: float
    m: float
    m2: float

    def __init__(self, e: float, px: float, py: float, pz: float) -> None: ...
    def set_e(self, value: float) -> None: ...
    def set_px(self, value: float) -> None: ...
    def set_py(self, value: float) -> None: ...
    def set_pz(self, value: float) -> None: ...
    def boost_along(self, other: FourMomentum) -> float: ...
    def __add__(self, other: FourMomentum) -> FourMomentum: ...
    def __sub__(self, other: FourMomentum) -> FourMomentum: ...

class FourMomentum64:
    e: float
    px: float
    py: float
    pz: float
    m: float
    m2: float

    def __init__(self, e: float, px: float, py: float, pz: float) -> None: ...
    def set_e(self, value: float) -> None: ...
    def set_px(self, value: float) -> None: ...
    def set_py(self, value: float) -> None: ...
    def set_pz(self, value: float) -> None: ...
    def boost_along(self, other: FourMomentum64) -> float: ...
    def __add__(self, other: FourMomentum64) -> FourMomentum64: ...
    def __sub__(self, other: FourMomentum64) -> FourMomentum64: ...

class FourMomentum32:
    e: float
    px: float
    py: float
    pz: float
    m: float
    m2: float

    def __init__(self, e: float, px: float, py: float, pz: float) -> None: ...
    def set_e(self, value: float) -> None: ...
    def set_px(self, value: float) -> None: ...
    def set_py(self, value: float) -> None: ...
    def set_pz(self, value: float) -> None: ...
    def boost_along(self, other: FourMomentum32) -> float: ...
    def __add__(self, other: FourMomentum32) -> FourMomentum32: ...
    def __sub__(self, other: FourMomentum32) -> FourMomentum32: ...

class Event:
    index: int
    weight: float
    beam_p4: FourMomentum
    recoil_p4: FourMomentum
    daughter_p4s: list[FourMomentum]
    eps: list[float]

class Event64:
    index: int
    weight: float
    beam_p4: FourMomentum64
    recoil_p4: FourMomentum64
    daughter_p4s: list[FourMomentum64]
    eps: list[float]

class Event32:
    index: int
    weight: float
    beam_p4: FourMomentum32
    recoil_p4: FourMomentum32
    daughter_p4s: list[FourMomentum32]
    eps: list[float]

class Dataset:
    events: list[Event]
    weights: list[float]

    def __getitem__(self, index: int) -> Event: ...
    def __len__(self) -> int: ...
    def split_m(
        self,
        range: tuple[float, float],  # noqa: A002
        bins: int,
        p1_indices: list[float] | None = None,
        p2_indices: list[float] | None = None,
    ) -> tuple[list[list[int]], list[int], list[int]]: ...
    def get_bootstrap_indices(self, seed: int) -> list[int]: ...
    @staticmethod
    def from_events(events: list[Event]) -> Dataset: ...
    @staticmethod
    def from_dict(data: dict[str, list[float | list[float]]]) -> Dataset: ...
    @staticmethod
    def from_parquet(path: str) -> Dataset: ...
    @staticmethod
    def from_parquet_eps_in_beam(path: str) -> Dataset: ...
    @staticmethod
    def from_parquet_with_eps(path: str, eps: list[float]) -> Dataset: ...
    @staticmethod
    def from_parquet_unpolarized(path: str) -> Dataset: ...
    @staticmethod
    def from_root(path: str) -> Dataset: ...

class Dataset64:
    events: list[Event64]
    weights: list[float]

    def __getitem__(self, index: int) -> Event64: ...
    def __len__(self) -> int: ...
    def split_m(
        self,
        range: tuple[float, float],  # noqa: A002
        bins: int,
        p1_indices: list[float] | None = None,
        p2_indices: list[float] | None = None,
    ) -> tuple[list[list[int]], list[int], list[int]]: ...
    def get_bootstrap_indices(self, seed: int) -> list[int]: ...
    @staticmethod
    def from_events(events: list[Event64]) -> Dataset64: ...
    @staticmethod
    def from_dict(data: dict[str, list[float | list[float]]]) -> Dataset64: ...
    @staticmethod
    def from_parquet(path: str) -> Dataset64: ...
    @staticmethod
    def from_parquet_eps_in_beam(path: str) -> Dataset64: ...
    @staticmethod
    def from_parquet_with_eps(path: str, eps: list[float]) -> Dataset64: ...
    @staticmethod
    def from_parquet_unpolarized(path: str) -> Dataset64: ...
    @staticmethod
    def from_root(path: str) -> Dataset64: ...

class Dataset32:
    events: list[Event32]
    weights: list[float]

    def __getitem__(self, index: int) -> Event32: ...
    def __len__(self) -> int: ...
    def split_m(
        self,
        range: tuple[float, float],  # noqa: A002
        bins: int,
        p1_indices: list[float] | None = None,
        p2_indices: list[float] | None = None,
    ) -> tuple[list[list[int]], list[int], list[int]]: ...
    def get_bootstrap_indices(self, seed: int) -> list[int]: ...
    @staticmethod
    def from_events(events: list[Event32]) -> Dataset32: ...
    @staticmethod
    def from_dict(data: dict[str, list[float | list[float]]]) -> Dataset32: ...
    @staticmethod
    def from_parquet(path: str) -> Dataset32: ...
    @staticmethod
    def from_parquet_eps_in_beam(path: str) -> Dataset32: ...
    @staticmethod
    def from_parquet_with_eps(path: str, eps: list[float]) -> Dataset32: ...
    @staticmethod
    def from_parquet_unpolarized(path: str) -> Dataset32: ...
    @staticmethod
    def from_root(path: str) -> Dataset32: ...

@overload
def open(
    file_name: str | Path,
    tree_name: str | None = None,
    *,
    pol_in_beam: bool = False,
    f32: Literal[False] = False,
) -> Dataset64: ...  # noqa: A001
@overload
def open(
    file_name: str | Path,
    tree_name: str | None = None,
    *,
    pol_in_beam: bool = False,
    f32: Literal[True],
) -> Dataset32: ...  # noqa: A001
def open(
    file_name: str | Path,
    tree_name: str | None = None,
    *,
    pol_in_beam: bool = False,
    f32: bool = False,
) -> Dataset64 | Dataset32: ...  # noqa: A001
@overload
def minimizer(
    ell: ExtendedLogLikelihood64 | ExtendedLogLikelihood32,
    method: Literal['Minuit'],
    *args: Any,
    indices_data: list[int] | None = None,
    indices_mc: list[int] | None = None,
    num_threads: int = 1,
    minimizer_kwargs: dict[str, Any] | None = None,
) -> Minuit: ...

ScipyOptMethods = Literal[
    'Nelder-Mead',
    'Powell',
    'CG',
    'BFGS',
    'Newton-CG',
    'L-BFGS-B',
    'TNC',
    'COBYLA',
    'COBYQA',
    'SLSQP',
    'trust-constr',
    'dogleg',
    'trust-ncg',
    'trust-exact',
    'trust-krylov',
]

class ScipyCallable(Protocol):
    def __call__(self, x: ArrayLike, *args: Any) -> float: ...

class ScipyMinCallable(Protocol):
    def __call__(
        self, fun: ScipyCallable, x0: ArrayLike, args: tuple[Any], **kwargs_and_options: Any
    ) -> OptimizeResult: ...

@overload
def minimizer(
    ell: ExtendedLogLikelihood64 | ExtendedLogLikelihood32,
    method: ScipyOptMethods,
    *args: Any,
    indices_data: list[int] | None = None,
    indices_mc: list[int] | None = None,
    num_threads: int = 1,
    minimizer_kwargs: dict[str, Any] | None = None,
) -> Callable[[], OptimizeResult]: ...
@overload
def minimizer(
    ell: ExtendedLogLikelihood64 | ExtendedLogLikelihood32,
    method: ScipyMinCallable,
    *args: Any,
    indices_data: list[int] | None = None,
    indices_mc: list[int] | None = None,
    num_threads: int = 1,
    minimizer_kwargs: dict[str, Any] | None = None,
) -> Callable[[], OptimizeResult]: ...
def minimizer(
    ell: ExtendedLogLikelihood64 | ExtendedLogLikelihood32,
    method: Literal['Minuit'] | ScipyOptMethods | ScipyMinCallable | None = None,
    *args: Any,
    indices_data: list[int] | None = None,
    indices_mc: list[int] | None = None,
    num_threads: int = 1,
    minimizer_kwargs: dict[str, Any] | None = None,
) -> Minuit | Callable[[], OptimizeResult]: ...

class Manager:
    model: Model
    dataset: Dataset
    root: Amplitude
    amplitudes: list[Amplitude]
    parameters: list[Parameter]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, model: Model, dataset: Dataset) -> None: ...
    def __call__(
        self, parameters: list[float], *, indices: list[int] | None = None, parallel: bool = True
    ) -> list[float]: ...
    def evaluate(
        self, parameters: list[float], *, indices: list[int] | None = None, parallel: bool = True
    ) -> list[float]: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class Manager64:
    model: Model64
    dataset: Dataset64
    root: Amplitude64
    amplitudes: list[Amplitude64]
    parameters: list[Parameter64]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, model: Model64, dataset: Dataset64) -> None: ...
    def __call__(
        self, parameters: list[float], *, indices: list[int] | None = None, parallel: bool = True
    ) -> list[float]: ...
    def evaluate(
        self, parameters: list[float], *, indices: list[int] | None = None, parallel: bool = True
    ) -> list[float]: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class Manager32:
    model: Model32
    dataset: Dataset32
    root: Amplitude32
    amplitudes: list[Amplitude32]
    parameters: list[Parameter32]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, model: Model32, dataset: Dataset32) -> None: ...
    def __call__(
        self, parameters: list[float], *, indices: list[int] | None = None, parallel: bool = True
    ) -> list[float]: ...
    def evaluate(
        self, parameters: list[float], *, indices: list[int] | None = None, parallel: bool = True
    ) -> list[float]: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class ExtendedLogLikelihood:
    data_manager: Manager
    mc_manager: Manager
    root: Amplitude
    amplitudes: list[Amplitude]
    parameters: list[Parameter]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, data_manager: Manager, mc_manager: Manager) -> None: ...
    def __call__(
        self,
        parameters: list[float],
        *,
        indices_data: list[float] | None = None,
        indices_mc: list[float] | None = None,
        parallel: bool = True,
    ) -> float: ...
    def evaluate(
        self,
        parameters: list[float],
        indices_data: list[int] | None = None,
        indices_mc: list[int] | None = None,
        parallel: bool = True,
    ) -> float: ...
    def intensity(
        self,
        parameters: list[float],
        dataset_mc: Dataset,
        *,
        indices_data: list[int] | None = None,
        indices_mc: list[int] | None = None,
        parallel: bool = True,
    ) -> list[float]: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class ExtendedLogLikelihood64:
    data_manager: Manager64
    mc_manager: Manager64
    root: Amplitude64
    amplitudes: list[Amplitude64]
    parameters: list[Parameter64]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, data_manager: Manager64, mc_manager: Manager64) -> None: ...
    def __call__(
        self,
        parameters: list[float],
        *,
        indices_data: list[float] | None = None,
        indices_mc: list[float] | None = None,
        parallel: bool = True,
    ) -> float: ...
    def evaluate(
        self,
        parameters: list[float],
        indices_data: list[int] | None = None,
        indices_mc: list[int] | None = None,
        parallel: bool = True,
    ) -> float: ...
    def intensity(
        self,
        parameters: list[float],
        dataset_mc: Dataset64,
        *,
        indices_data: list[int] | None = None,
        indices_mc: list[int] | None = None,
        parallel: bool = True,
    ) -> list[float]: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class ExtendedLogLikelihood32:
    data_manager: Manager32
    mc_manager: Manager32
    root: Amplitude32
    amplitudes: list[Amplitude32]
    parameters: list[Parameter32]
    bounds: list[tuple[float, float]]
    initial: list[float]
    n_free: int

    def __init__(self, data_manager: Manager32, mc_manager: Manager32) -> None: ...
    def __call__(
        self,
        parameters: list[float],
        *,
        indices_data: list[float] | None = None,
        indices_mc: list[float] | None = None,
        parallel: bool = True,
    ) -> float: ...
    def evaluate(
        self,
        parameters: list[float],
        indices_data: list[int] | None = None,
        indices_mc: list[int] | None = None,
        parallel: bool = True,
    ) -> float: ...
    def intensity(
        self,
        parameters: list[float],
        dataset_mc: Dataset32,
        *,
        indices_data: list[int] | None = None,
        indices_mc: list[int] | None = None,
        parallel: bool = True,
    ) -> list[float]: ...
    def fix(self, amplitude_1: str, parameter_1: str, value: float) -> None: ...
    def free(self, amplitude_1: str, parameter_1: str) -> None: ...
    def set_bounds(
        self, amplitude_1: str, parameter_1: str, bounds: tuple[float, float]
    ) -> None: ...
    def set_initial(self, amplitude_1: str, parameter_1: str, initial: float) -> None: ...
    def activate(self, amplitude: str) -> None: ...
    def activate_all(self) -> None: ...
    def isolate(self, amplitudes: list[str]) -> None: ...
    def deactivate(self, amplitude: str) -> None: ...
    def deactivate_all(self) -> None: ...

class NelderMead:
    def __init__(
        self,
        ell: ExtendedLogLikelihood,
        *,
        simplex_size: float = 1.0,
        reflection_coeff: float = 1.0,
        expansion_coeff: float = 2.0,
        outside_contraction_coeff: float = 0.5,
        inside_contraction_coeff: float = 0.5,
        shrink_coeff: float = 0.5,
        min_simplex_standard_deviation: float = 1e-8,
    ) -> None: ...
    @staticmethod
    def adaptive(ell, *, simplex_size=1.0, min_simplex_standard_deviation=1e-8) -> NelderMead: ...
    def initialize(self) -> None: ...
    def step(self) -> None: ...
    def check_for_termination(self) -> bool: ...
    def minimize(self, steps: int) -> None: ...
    def best(self) -> tuple[list[float], float]: ...

class NelderMead64:
    def __init__(
        self,
        ell: ExtendedLogLikelihood64,
        *,
        simplex_size: float = 1.0,
        reflection_coeff: float = 1.0,
        expansion_coeff: float = 2.0,
        outside_contraction_coeff: float = 0.5,
        inside_contraction_coeff: float = 0.5,
        shrink_coeff: float = 0.5,
        min_simplex_standard_deviation: float = 1e-8,
    ) -> None: ...
    @staticmethod
    def adaptive(ell, *, simplex_size=1.0, min_simplex_standard_deviation=1e-8) -> NelderMead64: ...
    def initialize(self) -> None: ...
    def step(self) -> None: ...
    def check_for_termination(self) -> bool: ...
    def minimize(self, steps: int) -> None: ...
    def best(self) -> tuple[list[float], float]: ...

class NelderMead32:
    def __init__(
        self,
        ell: ExtendedLogLikelihood32,
        *,
        simplex_size: float = 1.0,
        reflection_coeff: float = 1.0,
        expansion_coeff: float = 2.0,
        outside_contraction_coeff: float = 0.5,
        inside_contraction_coeff: float = 0.5,
        shrink_coeff: float = 0.5,
        min_simplex_standard_deviation: float = 1e-8,
    ) -> None: ...
    @staticmethod
    def adaptive(ell, *, simplex_size=1.0, min_simplex_standard_deviation=1e-8) -> NelderMead32: ...
    def initialize(self) -> None: ...
    def step(self) -> None: ...
    def check_for_termination(self) -> bool: ...
    def minimize(self, steps: int) -> None: ...
    def best(self) -> tuple[list[float], float]: ...
